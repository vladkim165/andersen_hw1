# ДЗ №1:

1. С помощью встроенной браузерной функции prompt поочерёдно ввести два значения. Если оба значения являются валидными числами, то вывести в консоли результат в виде первого числа в системе счисления второго.
   Если хотя бы одно из введённых значений является некорректным числом, вывести в консоли сообщение: "Некорректный ввод!" и завершить программу.

   > ### Примеры:
   >
   > - Вводим 10 и 2, получаем 1010
   > - Вводим 872 и 8, получаем 1550
   > - Вводим 2 и 'abc', получаем "Некорректный ввод!"

2. С помощью встроенной браузерной функции prompt поочерёдно ввести два значения. Если первое значение является невалидным числом, вывести в консоли сообщение: "Некорректный ввод!" и завершить программу. В ином случае, если второе значение является невалидным числом вывести такое же сообщение об ошибке и завершить программу. Если оба значения являются валидными числами, то вывести в консоль результат в виде: "Ответ: [сумма двух чисел], [частное двух чисел]."
   > ### Примеры:
   >
   > - Вводим 10 и 2, получаем "Ответ: 12, 5."
   > - Вводим 872 и 8, получаем "Ответ: 880, 109."
   > - Вводим 'abc', получаем "Некорректный ввод!"

P.s. значения по типу '', не являются валидным числом, даже при условии того, что могут быть корректно приведены к нему.
Валидными числами считаются именно числа.

# Задание №2:

1. Написать свою функцию для глубокого копирования объектов. При этом алгоритм должен осуществляться вручную (никаких вариантов с использованием готовых библиотек или JSON.stringify() + JSON.parse(), за это сразу 0 баллов за первую задачу). Функция должна называться makeObjectDeepCopy. Это важно, т.к. проверять буду тестами. Принимать функция должна один параметр - объект, копию которого нужно сделать.

2. Написать функцию, которая принимает три аргумента: массив чисел, первое значение интервала, второе значение интервала. Результатом вызова функции должен быть массив из значений переданного массива (в качестве первого параметра), которые входят в этот интервал (концы включая). Если в качестве первого параметра передан не массив или массив, содержащий не только числа - кидать ошибку (throw new Error(...)). Если хотя бы одно из значений интервала (имеются ввиду параметры функции selectFromInterval) - невалидное число!, то также кидать ошибку.
   Если первое значение интервала < второго (имеются ввиду параметры функции selectFromInterval), то считать за интервал значения от первого до второго, в ином случае - от второго до первого.
   Функция должна называться selectFromInterval. Это важно, т.к. проверять буду тестами.

   > ### Примеры:

   > - Вызываем функцию: selectFromInterval([1,3,5], 5, 2)
   > - Получаем результат: [3,5]
   > - Вызываем функцию: selectFromInterval([-2, -15, 0, 4], -13, -5)
   > - Получаем результат: []
   > - Вызываем функцию: selectFromInterval(['aaa'], 2, 3)
   > - Получаем результат: Ошибка!

3. Создать обычный объект и сделать его итерируемым. При этом итерация должна происходить следующим образом:
   Должны поочерёдно проходиться все значения от свойства объекта from, до свойства to. (в случае если to < from - должна возникать ошибка).
   Если to или from не указаны ИЛИ to или from не являются числами, должна возникать ошибка. Объект должен называться myIterable. Это важно, т.к. проверять буду тестами.

   > Примеры:

   > - const myIterable = { from: 1, to: 4 };
   > - for (let item of myIterable) {
   > - console.log(item); // 1, 2, 3, 4
   > - }

   > - const myIterable = { from: 'aaa', to: 4 };
   > - for (let item of myIterable) { // Ошибка!
   > - console.log(item);
   > - }

# Задание №3:

1. Реализовать функцию concatStrings, которая может быть вызвана следующим образом: concatStrings('first')('second')('third')().
   Результатом вызова данной функции должна являться новая строка, содержащая все переданные таким образом строки.
   Если одно из значений является невалидной строкой (пустая строка - это валидная строка), то возвращать результат, полученный до текущего момента (ошибок не бросать!)
   Кроме этого добавить функции второй необязательный параметр - separator. Он также должен являться валидной строкой, однако в случаях, когда вместо валидной строки на его место передано что-то ещё - запускаем функцию как будто без него вообще (иными словами игнорируем, никаких ошибок кидать не нужно). Если же всё-таки параметр был валидной строкой, то результирующая строка должна содержать все переденные строки, разделённые значчением separator.

> ### Примеры:
>
> - Вызываем функцию: concatStrings('first')('second')('third')()
> - Получаем результат: 'firstsecondthird'
> - Вызываем функцию: concatStrings('first', null)('second')()('third')
> - Получаем результат: 'firstsecond'
> - Вызываем функцию: concatStrings('first', '123')('second')('third')()
> - Получаем результат: 'first123second123third'
> - Вызываем функцию: concatStrings('some-value')('')('')(null)
> - Получаем результат: 'some-value'
> - Вызываем функцию: concatStrings('some-value')(2)
> - Получаем результат: 'some-value'
> - Вызываем функцию: concatStrings('some-value')('333')(123n)('end')
> - Получаем результат: 'some-val333'

# Задание №4:

1. Написать функцию createDebounceFunction. Она должна принимать два аргумента: callback-функцию и задержку в миллисекундах. Данная функция должна возвращать новую функцию, вызывающую callback-функцию с задержкой в переданное количество миллисекунд. ПРИ ЭТОМ! Если за то время, пока внутрення callback-функция ждёт своего вызова, наша созданная функция вызывается ещё раз, то "счётчик" времени должен сбрасываться и начинаться заново (т.е. вызова внутренней функции произойти не должно).

> Пример:
>
> - const log100 = () => console.log(100);
> - const debounceLog100 = createDebounceFunction(log100, 1000);
> - debounceLog100();
> - setTimeout(debounceLog100, 200); // так как задержка в 1000мс и новый вызов этой же функции происходит через 200 миллисекунд, то таймер запускается заново
> - setTimeout(debounceLog100, 400); // снова сбрасываем таймер ещё через 200 миллисекунд

> - Вывод в консоли значения 100 примерно через 1000мс + 200мс + 200мс

# ДЗ №5:

1. Написать свою реализацию встроенной функции массивов filter. Назвать функцию myFilter и сделать так, чтобы любой массив мог использовать данную функцию как "родную". В качестве параметров он должен принимать callback-функцию и как необязательный параметр объект, который будет использован в качестве this в рамках внутренних вызовов данной callback-функции.
   В конечном итоге ваша реализация myFilter должна работать точно также как и встроенный метод filter. Callback-функция, переданная в качестве параметра, также должна вызываться с теми же параметрами, что и оригинал (элемент, индекс, массив).

2. Создать класс Calculator. Конструктор класса должен принимать два валидных числа, иначе (если параметра не два или хотя бы один из них невалидный number) бросать ошибку (throw new Error('')). Данный класс должен иметь методы setX, setY, logSum, logMul, logSub, logDiv.

- setX(num) - задаёт первому из чисел новое значение. Кидать ошибку если параметр не передан или является невалидным числом;
- setY(num) - задаёт второму из чисел новое значение. Кидать ошибку если параметр не передан или является невалидным числом;
- logSum() - выводит в консоль сумму двух наших чисел внутри класса;
- logMul() - выводит в консоль произведение двух наших чисел внутри класса;
- logSub() - выводит в консоль разность двух наших чисел внутри класса;
- logDiv() - выводит в консоль частное двух наших чисел внутри класса ИЛИ кидает ошибку, если второе число (Y)

равняется нулю.
!ВАЖНО! Все методы класса должны отрабатывать корректно ДАЖЕ в случае копирования функций в отдельные переменные.

> Пример:
>
> - const calculator = new Calculator(12, 3);
> - calculator.logSum(); // 15
> - calculator.logDiv(); // 4
> - calculator.setX(15);
> - calculator.logDiv(); // 5
> - const logCalculatorDiv = calculator.logDiv;
> - logCalculatorDiv(); // 5
> - calculator.setY(444n); // Ошибка!

> - P.s. Infinity, -Infinity и NaN - это невалидные числа

3. Создать класс Stack.
   В качестве единственного необязательного параметра конструктор Stack должен принимать максимальное количество элементов в стеке. Если параметр является невалидным числом, генерировать ошибку. Если параметр не указан, задавать максимальный размер стека равным 10.

Реализовать публичные методы:

- push(elem) - добавить новый элемент в стек (генерировать ошибку, если стек переполнен);
- pop() - удалить верхний элемент стека и вернуть его (генерировать ошибку, если стек пуст);
- peek() - получить верхний элемент стека (вернуть null, если стек пуст);
- isEmpty() - возвращает логическое значение (пуст стек или нет);
- toArray() - возвращает новый массив, состоящий из элементов стека.

Реализовать статические публичные методы:

- fromIterable(iterable) - возвращает новый Stack, элементами которого служат элементы переданной итерируемой сущности. Максимальное количество элементов такого стека должно быть равно длине этой сущности. Если сущность не является итерируемой генерировать ошибку.

# ДЗ №7 -

Создать класс Car.  
В нём должны быть свойства:

> - brand (строка от 1 до 50 символов включительно)
> - model (строка от 1 до 50 символов включительно)
> - yearOfManufacturing (число от 1900 до текущего года включительно)
> - maxSpeed (число от 100 до 300 км/ч)
> - maxFuelVolume (число в литрах от 5 до 20)
> - fuelConsumption (число в л/100км)
> - currentFuelVolume (число в литрах, по умолчанию 0)
> - isStarted (логический тип, по умолчанию false)
> - mileage (число в километрах, по умолчанию 0)

И методы:

> - start()
>   Если заведена, выкидывать ошибку с текстом 'Машина уже заведена'
>   Если не заведена, перевести соответствующий флаг в нужное состояние

> - shutDownEngine()
>   Если не заведена, выкинуть ошибку с текстом 'Машина ещё не заведена'
>   Если заведена, перевести соответствующий флаг в нужное состояние

> - fillUpGasTank(кол-во топлива в литрах)
>   Если введено что-либо, кроме числа, выкидывать ошибку с текстом 'Неверное количество топлива для заправки'
>   Если введено отрицательное число или 0, выкидывать ошибку с текстом 'Неверное количество топлива для заправки'
>   Если в результате заправки макс. объем топлива будет превышен, то не производить заправку, а выкидывать ошибку с текстом 'Топливный бак переполнен'
>   В иных случаях увеличить текущий показатель топлива

> - drive(скорость, кол-во часов)
>   Если в качестве скорости поступает что-то кроме числа, отрицательное число или 0, то выкидывать ошибку с текстом 'Неверная скорость'
>   Если в качестве количества часов поступает что-то кроме числа, отрицательное число или 0, выкидывать ошибку с текстом 'Неверное количество часов'
>   Если скорость превышает максимальную, то выкидывать ошибку с текстом 'Машина не может ехать так быстро'
>   Если машина не заведена, выкидывать ошибку с текстом 'Машина должна быть заведена, чтобы ехать'
>   Если недостаточно топлива для совершения поездки, выкидывать ошибку с текстом 'Недостаточно топлива'
>   В иных случаях вычесть необходимое топливо и добавить пробег

Ни одно из свойств не должно иметь возможности изменяться извне. Все должны быть приватными. Для свойств brand, model, yearOfManufacturing, maxSpeed, maxFuelVolume, fuelConsumption реализовать соответствующие геттеры (для получения текущего значения) и сеттеры (для установки нового значения, согласно ограничениям). Для свойств currentFuelVolume, isStarted и mileage реализовать только геттеры (для получения текущего значения). Все геттеры и сеттеры должны иметь те же имена, что описаны выше.
